could this work to "skip" over steps that have been processed already?

private initMachine() {
    const machineSetup = setup({
        types: {
            input: {} as {orderId: UUID, productId: number, quantity: number},
            context: {} as {
                orderId: UUID, 
                productId: number, 
                quantity: number,
                // Track what's been completed
                completedSteps: Set<string>
            },
            events: {} as 
                {type: 'receivedInventoryResponse', successful: boolean} | 
                {type: 'receivedShippingResponse', successful: boolean}
        },
        guards: {
            // Check if work already done
            isOrderCreated: ({context}) => context.completedSteps.has('createOrder'),
            isInventoryHandled: ({context}) => context.completedSteps.has('handleInventoryResponse'),
        },
        actors: {
            createOrder: fromPromise(async ({input}: {input: {orderId: UUID, productId: number, quantity: number}}) => { 
                await this.ordersService.createOrder(
                    input.orderId, 
                    input.productId, 
                    input.quantity, 
                    this.actors.get(input.orderId).getPersistedSnapshot()
                )
                return 'createOrder' // Return step name
            }),
            handleInventoryResponse: fromPromise(async ({input}: {input: {orderId: UUID, productId: number, successful: boolean, quantity: number}}) => {
                await this.inventoryService.handleInventoryMessage(
                    input.orderId, 
                    input.productId, 
                    input.quantity, 
                    input.successful, 
                    this.actors.get(input.orderId).getPersistedSnapshot()
                )
                return 'handleInventoryResponse' // Return step name
            }),
        },
        actions: {
            markStepComplete: ({context, event}) => {
                // XState 5: use assign properly
                context.completedSteps.add(event.output)
            }
        }
    })

    const machine = machineSetup.createMachine({
        context: ({input}) => ({
            orderId: input.orderId,
            productId: input.productId,
            quantity: input.quantity,
            completedSteps: new Set<string>() // Initialize empty
        }),
        initial: 'createOrder',
        states: {
            createOrder: {
                always: {
                    // Skip if already done
                    guard: 'isOrderCreated',
                    target: 'waitForInventoryResponse'
                },
                invoke: {
                    src: 'createOrder',
                    input: ({context}) => ({
                        orderId: context.orderId, 
                        productId: context.productId, 
                        quantity: context.quantity
                    }),
                    onDone: {
                        target: 'waitForInventoryResponse',
                        actions: 'markStepComplete' // Mark as done
                    },
                    onError: {
                        target: 'error'
                    }
                },
            },
            waitForInventoryResponse: {
                entry: {
                    type: 'persistState',
                    params: ({context}) => ({
                        orderId: context.orderId, 
                        state: STATE.WAIT_FOR_INVENTORY_RESPONSE
                    })
                },
                on: {
                    receivedInventoryResponse: 'handleInventoryResponse'
                }
            },
            handleInventoryResponse: {
                always: {
                    // Skip if already done
                    guard: 'isInventoryHandled',
                    target: 'waitForShippingResponse'
                },
                invoke: {
                    src: 'handleInventoryResponse',
                    input: ({context, event}) => ({
                        orderId: context.orderId, 
                        productId: context.productId, 
                        quantity: context.quantity,
                        successful: event.successful  
                    }),
                    onDone: {
                        target: 'waitForShippingResponse',
                        actions: 'markStepComplete' // Mark as done
                    },
                    onError: {
                        target: 'error'
                    }
                }
            },
            // ... rest of states
        },
    })
    return machine;
}


//////// inventory service ////////////////
handleInventoryMessage = async (orderId: UUID, productId: number, quantity: number, successful: boolean, sagaSnapshot: SagaSnapshot<unknown>) => {
    console.log('handling inventory message')
    
    // NO MORE DB CHECK - state machine handles it!
    
    await this.datasource.transaction(async manager => {
        const inboxRepository = manager.getRepository(InboxMessage)
        const outboxRepository = manager.getRepository(OutboxMessage)
        const snapshotRepository = manager.getRepository(Snapshot)
        
        const inboxMessage = new InboxMessage(orderId, INBOX_MESSAGE_TYPE.INVENTORY_REMOVE_RESPONSE, successful)
        const outboxMessage = new OutboxMessage(orderId, productId, quantity, OUTBOX_MESSAGE_TYPE.SHIP_PRODUCT)
        const snapshot = new Snapshot(orderId, STATE.HANDLE_INVENTORY_RESPONSE, sagaSnapshot)
        
        await inboxRepository.save(inboxMessage)
        await outboxRepository.save(outboxMessage)
        await snapshotRepository.save(snapshot)
    })
}

//////////////// recovery ////////////////////////
public restoreFromDatabase = async () => {
    const snapshots = await this.datasource.getRepository(Snapshot).find()
    
    snapshots.forEach(snapshotEntity => {
        const snapshot = JSON.parse(snapshotEntity.snapshot)
        const machine = this.initMachine()
        const actor = createActor(machine, {snapshot})
        
        // Context has completedSteps: Set(['createOrder', 'handleInventoryResponse'])
        // When started, guards check and skip already-completed states
        actor.start()
        
        this.actors.set(snapshotEntity.orderId, actor)
    })
}
